module Pine exposing (..)

import BigInt
import Bytes
import Maybe.Extra
import SHA256


type Value
    = BlobValue (List Int)
    | ListValue (List Value)


hashBytesFromValue : Value -> Bytes.Bytes
hashBytesFromValue =
    hashDigestFromValue >> SHA256.toBytes


hashDigestFromValue : Value -> SHA256.Digest
hashDigestFromValue value =
    case value of
        BlobValue bytes ->
            let
                prefix =
                    "blob " ++ String.fromInt (List.length bytes)
            in
            SHA256.fromByteValues ((prefix |> String.toList |> List.map Char.toCode) ++ [ 0 ] ++ bytes)

        ListValue elements ->
            let
                prefix =
                    "list " ++ String.fromInt (List.length elements)
            in
            SHA256.fromByteValues
                ((prefix |> String.toList |> List.map Char.toCode)
                    ++ [ 0 ]
                    ++ (elements |> List.concatMap (hashDigestFromValue >> SHA256.toByteValues))
                )


valueFromString : String -> Value
valueFromString string =
    let
        charsBytes : List (List Int)
        charsBytes =
            List.map blobBytesFromChar (String.toList string)
    in
    BlobValue
        (List.concat charsBytes)


valueFromChar : Char -> Value
valueFromChar char =
    BlobValue (blobBytesFromChar char)


blobBytesFromChar : Char -> List Int
blobBytesFromChar char =
    let
        charCode : Int
        charCode =
            Char.toCode char
    in
    [ modBy 0x0100 (charCode // 0x01000000)
    , modBy 0x0100 (charCode // 0x00010000)
    , modBy 0x0100 (charCode // 0x0100)
    , modBy 0x0100 charCode
    ]


stringFromValue : Value -> Result String String
stringFromValue value =
    case value of
        ListValue charsValues ->
            case charsValues |> List.map bigIntFromUnsignedValue |> Maybe.Extra.combine of
                Nothing ->
                    Err "Failed to map list elements to unsigned integers."

                Just chars ->
                    chars
                        |> List.map (BigInt.toString >> String.toInt >> Maybe.map Char.fromCode)
                        |> Maybe.Extra.combine
                        |> Maybe.map String.fromList
                        |> Result.fromMaybe "Programming error: Failed to map from integers to chars."

        _ ->
            Err "Only a ListValue can represent a string."


valueFromBigInt : BigInt.BigInt -> Value
valueFromBigInt =
    blobValueFromBigInt >> BlobValue


blobValueFromBigInt : BigInt.BigInt -> List Int
blobValueFromBigInt bigint =
    let
        value =
            BigInt.abs bigint

        signByte =
            if value == bigint then
                0

            else
                0x80

        unsignedBytesFromIntValue intValue =
            if BigInt.lt intValue (BigInt.fromInt 0x0100) then
                String.toInt (BigInt.toString intValue) |> Maybe.map List.singleton

            else
                case BigInt.divmod intValue (BigInt.fromInt 0x0100) of
                    Nothing ->
                        Nothing

                    Just ( upper, lower ) ->
                        case unsignedBytesFromIntValue upper of
                            Nothing ->
                                Nothing

                            Just upperBytes ->
                                case String.toInt (BigInt.toString lower) of
                                    Nothing ->
                                        Nothing

                                    Just lowerByte ->
                                        Just (upperBytes ++ [ lowerByte ])
    in
    signByte :: Maybe.withDefault [] (unsignedBytesFromIntValue value)


unsignedBlobValueFromBigInt : BigInt.BigInt -> Maybe (List Int)
unsignedBlobValueFromBigInt bigint =
    case blobValueFromBigInt bigint of
        [] ->
            Nothing

        signByte :: unsignedBytes ->
            if signByte == 0 then
                Just unsignedBytes

            else
                Nothing


bigIntFromValue : Value -> Result String BigInt.BigInt
bigIntFromValue value =
    case value of
        BlobValue blobValue ->
            bigIntFromBlobValue blobValue

        _ ->
            Err "Only a BlobValue can represent an integer."


bigIntFromBlobValue : List Int -> Result String BigInt.BigInt
bigIntFromBlobValue blobValue =
    case blobValue of
        [] ->
            Err "Empty blob is not a valid integer because the sign byte is missing. Did you mean to use an unsigned integer?"

        sign :: intValueBytes ->
            if sign /= 0 && sign /= 0x80 then
                Err ("Unexpected value for sign byte of integer: " ++ String.fromInt sign)

            else
                intValueBytes
                    |> bigIntFromUnsignedBlobValue
                    |> (if sign == 0 then
                            identity

                        else
                            BigInt.negate
                       )
                    |> Ok


bigIntFromUnsignedValue : Value -> Maybe BigInt.BigInt
bigIntFromUnsignedValue value =
    case value of
        BlobValue intValueBytes ->
            Just (bigIntFromUnsignedBlobValue intValueBytes)

        _ ->
            Nothing


bigIntFromUnsignedBlobValue : List Int -> BigInt.BigInt
bigIntFromUnsignedBlobValue intValueBytes =
    intValueBytes
        |> List.foldl
            (\nextByte aggregate ->
                BigInt.add (BigInt.fromInt nextByte) (BigInt.mul (BigInt.fromInt 0x0100) aggregate)
            )
            (BigInt.fromInt 0)


hexadecimalRepresentationFromBlobValue : List Int -> String
hexadecimalRepresentationFromBlobValue =
    List.map BigInt.fromInt
        >> List.map (BigInt.toHexString >> String.padLeft 2 '0')
        >> String.join ""
